/**
 * Generated by orval v7.1.0 üç∫
 * Do not edit manually.
 * A8 Pump Fun API
 * OpenAPI spec version: 0.0.12
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import type {
  AllocationResponse,
  AnalyticDataResponse,
  CoinHolderResponse,
  CommentControllerGetPaginationParams,
  CommentPaginationResponse,
  CommentResponse,
  CreateCommentDto,
  CreateManyAllocationsDto,
  CreateMemeOffChainDto,
  CreateMemeOffChainResponse,
  CreateSwapRequestDto,
  FileUploadControllerUploadSingleBody,
  IpfsControllerUploadSingleBody,
  LikeCommentDto,
  MemeControllerQueryPaginationParams,
  MemePaginationResponse,
  MemeResponse,
  OHLCResponse,
  OhlcControllerFindParams,
  TransactionControllerGetLatestParams,
  TransactionControllerGetPaginationParams,
  TransactionControllerQueryAnalyticParams,
  TransactionHighLightResponse,
  TransactionPaginationResponse,
  UpdateUserDto,
  UserResponse,
} from "./models";
import { customClient } from "./custom-client";
import type { ErrorType, BodyType } from "./custom-client";

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

export const healthCheckControllerHealthCheck = (
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<void>(
    { url: `/api/health-check`, method: "GET", signal },
    options,
  );
};

export const getHealthCheckControllerHealthCheckQueryKey = () => {
  return [`/api/health-check`] as const;
};

export const getHealthCheckControllerHealthCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getHealthCheckControllerHealthCheckQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>
  > = ({ signal }) => healthCheckControllerHealthCheck(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type HealthCheckControllerHealthCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>
>;
export type HealthCheckControllerHealthCheckQueryError = ErrorType<unknown>;

export function useHealthCheckControllerHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
  TError = ErrorType<unknown>,
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
        TError,
        TData
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customClient>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useHealthCheckControllerHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
        TError,
        TData
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customClient>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useHealthCheckControllerHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customClient>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useHealthCheckControllerHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customClient>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getHealthCheckControllerHealthCheckQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const fileUploadControllerUploadSingle = (
  fileUploadControllerUploadSingleBody: BodyType<FileUploadControllerUploadSingleBody>,
  options?: SecondParameter<typeof customClient>,
) => {
  const formData = new FormData();
  if (fileUploadControllerUploadSingleBody.file !== undefined) {
    formData.append("file", fileUploadControllerUploadSingleBody.file);
  }

  return customClient<void>(
    {
      url: `/api/file-upload/single`,
      method: "POST",
      headers: { "Content-Type": "multipart/form-data" },
      data: formData,
    },
    options,
  );
};

export const getFileUploadControllerUploadSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fileUploadControllerUploadSingle>>,
    TError,
    { data: BodyType<FileUploadControllerUploadSingleBody> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof fileUploadControllerUploadSingle>>,
  TError,
  { data: BodyType<FileUploadControllerUploadSingleBody> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof fileUploadControllerUploadSingle>>,
    { data: BodyType<FileUploadControllerUploadSingleBody> }
  > = (props) => {
    const { data } = props ?? {};

    return fileUploadControllerUploadSingle(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FileUploadControllerUploadSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof fileUploadControllerUploadSingle>>
>;
export type FileUploadControllerUploadSingleMutationBody =
  BodyType<FileUploadControllerUploadSingleBody>;
export type FileUploadControllerUploadSingleMutationError = ErrorType<unknown>;

export const useFileUploadControllerUploadSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fileUploadControllerUploadSingle>>,
    TError,
    { data: BodyType<FileUploadControllerUploadSingleBody> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationResult<
  Awaited<ReturnType<typeof fileUploadControllerUploadSingle>>,
  TError,
  { data: BodyType<FileUploadControllerUploadSingleBody> },
  TContext
> => {
  const mutationOptions =
    getFileUploadControllerUploadSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

export const fileUploadControllerGet = (
  fileName: string,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<Blob>(
    {
      url: `/api/file-upload/${fileName}`,
      method: "GET",
      responseType: "blob",
      signal,
    },
    options,
  );
};

export const getFileUploadControllerGetQueryKey = (fileName: string) => {
  return [`/api/file-upload/${fileName}`] as const;
};

export const getFileUploadControllerGetQueryOptions = <
  TData = Awaited<ReturnType<typeof fileUploadControllerGet>>,
  TError = ErrorType<unknown>,
>(
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fileUploadControllerGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFileUploadControllerGetQueryKey(fileName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fileUploadControllerGet>>
  > = ({ signal }) => fileUploadControllerGet(fileName, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!fileName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof fileUploadControllerGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FileUploadControllerGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof fileUploadControllerGet>>
>;
export type FileUploadControllerGetQueryError = ErrorType<unknown>;

export function useFileUploadControllerGet<
  TData = Awaited<ReturnType<typeof fileUploadControllerGet>>,
  TError = ErrorType<unknown>,
>(
  fileName: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fileUploadControllerGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileUploadControllerGet>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useFileUploadControllerGet<
  TData = Awaited<ReturnType<typeof fileUploadControllerGet>>,
  TError = ErrorType<unknown>,
>(
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fileUploadControllerGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileUploadControllerGet>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useFileUploadControllerGet<
  TData = Awaited<ReturnType<typeof fileUploadControllerGet>>,
  TError = ErrorType<unknown>,
>(
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fileUploadControllerGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useFileUploadControllerGet<
  TData = Awaited<ReturnType<typeof fileUploadControllerGet>>,
  TError = ErrorType<unknown>,
>(
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fileUploadControllerGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getFileUploadControllerGetQueryOptions(
    fileName,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const ohlcControllerFind = (
  params: OhlcControllerFindParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<OHLCResponse>(
    { url: `/api/ohlc/history`, method: "GET", params, signal },
    options,
  );
};

export const getOhlcControllerFindQueryKey = (
  params: OhlcControllerFindParams,
) => {
  return [`/api/ohlc/history`, ...(params ? [params] : [])] as const;
};

export const getOhlcControllerFindQueryOptions = <
  TData = Awaited<ReturnType<typeof ohlcControllerFind>>,
  TError = ErrorType<unknown>,
>(
  params: OhlcControllerFindParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof ohlcControllerFind>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOhlcControllerFindQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof ohlcControllerFind>>
  > = ({ signal }) => ohlcControllerFind(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof ohlcControllerFind>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type OhlcControllerFindQueryResult = NonNullable<
  Awaited<ReturnType<typeof ohlcControllerFind>>
>;
export type OhlcControllerFindQueryError = ErrorType<unknown>;

export function useOhlcControllerFind<
  TData = Awaited<ReturnType<typeof ohlcControllerFind>>,
  TError = ErrorType<unknown>,
>(
  params: OhlcControllerFindParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof ohlcControllerFind>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ohlcControllerFind>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useOhlcControllerFind<
  TData = Awaited<ReturnType<typeof ohlcControllerFind>>,
  TError = ErrorType<unknown>,
>(
  params: OhlcControllerFindParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof ohlcControllerFind>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ohlcControllerFind>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useOhlcControllerFind<
  TData = Awaited<ReturnType<typeof ohlcControllerFind>>,
  TError = ErrorType<unknown>,
>(
  params: OhlcControllerFindParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof ohlcControllerFind>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useOhlcControllerFind<
  TData = Awaited<ReturnType<typeof ohlcControllerFind>>,
  TError = ErrorType<unknown>,
>(
  params: OhlcControllerFindParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof ohlcControllerFind>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOhlcControllerFindQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const userControllerCreate = (
  options?: SecondParameter<typeof customClient>,
) => {
  return customClient<UserResponse>(
    { url: `/api/user`, method: "POST" },
    options,
  );
};

export const getUserControllerCreateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userControllerCreate>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userControllerCreate>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userControllerCreate>>,
    void
  > = () => {
    return userControllerCreate(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof userControllerCreate>>
>;

export type UserControllerCreateMutationError = ErrorType<unknown>;

export const useUserControllerCreate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userControllerCreate>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationResult<
  Awaited<ReturnType<typeof userControllerCreate>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getUserControllerCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

export const userControllerUpdate = (
  updateUserDto: BodyType<UpdateUserDto>,
  options?: SecondParameter<typeof customClient>,
) => {
  return customClient<UserResponse>(
    {
      url: `/api/user`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: updateUserDto,
    },
    options,
  );
};

export const getUserControllerUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userControllerUpdate>>,
    TError,
    { data: BodyType<UpdateUserDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userControllerUpdate>>,
  TError,
  { data: BodyType<UpdateUserDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userControllerUpdate>>,
    { data: BodyType<UpdateUserDto> }
  > = (props) => {
    const { data } = props ?? {};

    return userControllerUpdate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof userControllerUpdate>>
>;
export type UserControllerUpdateMutationBody = BodyType<UpdateUserDto>;
export type UserControllerUpdateMutationError = ErrorType<unknown>;

export const useUserControllerUpdate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userControllerUpdate>>,
    TError,
    { data: BodyType<UpdateUserDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationResult<
  Awaited<ReturnType<typeof userControllerUpdate>>,
  TError,
  { data: BodyType<UpdateUserDto> },
  TContext
> => {
  const mutationOptions = getUserControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};

export const userControllerFindOne = (
  walletAddress: string,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<UserResponse>(
    { url: `/api/user/${walletAddress}`, method: "GET", signal },
    options,
  );
};

export const getUserControllerFindOneQueryKey = (walletAddress: string) => {
  return [`/api/user/${walletAddress}`] as const;
};

export const getUserControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = ErrorType<unknown>,
>(
  walletAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindOne>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserControllerFindOneQueryKey(walletAddress);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userControllerFindOne>>
  > = ({ signal }) =>
    userControllerFindOne(walletAddress, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!walletAddress,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userControllerFindOne>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UserControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof userControllerFindOne>>
>;
export type UserControllerFindOneQueryError = ErrorType<unknown>;

export function useUserControllerFindOne<
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = ErrorType<unknown>,
>(
  walletAddress: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindOne>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useUserControllerFindOne<
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = ErrorType<unknown>,
>(
  walletAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindOne>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useUserControllerFindOne<
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = ErrorType<unknown>,
>(
  walletAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindOne>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useUserControllerFindOne<
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = ErrorType<unknown>,
>(
  walletAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindOne>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUserControllerFindOneQueryOptions(
    walletAddress,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const transactionControllerGetPagination = (
  params: TransactionControllerGetPaginationParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<TransactionPaginationResponse>(
    { url: `/api/transaction`, method: "GET", params, signal },
    options,
  );
};

export const getTransactionControllerGetPaginationQueryKey = (
  params: TransactionControllerGetPaginationParams,
) => {
  return [`/api/transaction`, ...(params ? [params] : [])] as const;
};

export const getTransactionControllerGetPaginationQueryOptions = <
  TData = Awaited<ReturnType<typeof transactionControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTransactionControllerGetPaginationQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof transactionControllerGetPagination>>
  > = ({ signal }) =>
    transactionControllerGetPagination(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof transactionControllerGetPagination>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TransactionControllerGetPaginationQueryResult = NonNullable<
  Awaited<ReturnType<typeof transactionControllerGetPagination>>
>;
export type TransactionControllerGetPaginationQueryError = ErrorType<unknown>;

export function useTransactionControllerGetPagination<
  TData = Awaited<ReturnType<typeof transactionControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetPaginationParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetPagination>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerGetPagination>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useTransactionControllerGetPagination<
  TData = Awaited<ReturnType<typeof transactionControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetPagination>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerGetPagination>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useTransactionControllerGetPagination<
  TData = Awaited<ReturnType<typeof transactionControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useTransactionControllerGetPagination<
  TData = Awaited<ReturnType<typeof transactionControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTransactionControllerGetPaginationQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const transactionControllerGetLatest = (
  params?: TransactionControllerGetLatestParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<TransactionHighLightResponse[]>(
    { url: `/api/transaction/latest`, method: "GET", params, signal },
    options,
  );
};

export const getTransactionControllerGetLatestQueryKey = (
  params?: TransactionControllerGetLatestParams,
) => {
  return [`/api/transaction/latest`, ...(params ? [params] : [])] as const;
};

export const getTransactionControllerGetLatestQueryOptions = <
  TData = Awaited<ReturnType<typeof transactionControllerGetLatest>>,
  TError = ErrorType<unknown>,
>(
  params?: TransactionControllerGetLatestParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetLatest>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTransactionControllerGetLatestQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof transactionControllerGetLatest>>
  > = ({ signal }) =>
    transactionControllerGetLatest(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof transactionControllerGetLatest>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TransactionControllerGetLatestQueryResult = NonNullable<
  Awaited<ReturnType<typeof transactionControllerGetLatest>>
>;
export type TransactionControllerGetLatestQueryError = ErrorType<unknown>;

export function useTransactionControllerGetLatest<
  TData = Awaited<ReturnType<typeof transactionControllerGetLatest>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | TransactionControllerGetLatestParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetLatest>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerGetLatest>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useTransactionControllerGetLatest<
  TData = Awaited<ReturnType<typeof transactionControllerGetLatest>>,
  TError = ErrorType<unknown>,
>(
  params?: TransactionControllerGetLatestParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetLatest>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerGetLatest>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useTransactionControllerGetLatest<
  TData = Awaited<ReturnType<typeof transactionControllerGetLatest>>,
  TError = ErrorType<unknown>,
>(
  params?: TransactionControllerGetLatestParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetLatest>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useTransactionControllerGetLatest<
  TData = Awaited<ReturnType<typeof transactionControllerGetLatest>>,
  TError = ErrorType<unknown>,
>(
  params?: TransactionControllerGetLatestParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetLatest>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTransactionControllerGetLatestQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const transactionControllerQueryAnalytic = (
  params: TransactionControllerQueryAnalyticParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<AnalyticDataResponse>(
    { url: `/api/transaction/analytic-data`, method: "GET", params, signal },
    options,
  );
};

export const getTransactionControllerQueryAnalyticQueryKey = (
  params: TransactionControllerQueryAnalyticParams,
) => {
  return [
    `/api/transaction/analytic-data`,
    ...(params ? [params] : []),
  ] as const;
};

export const getTransactionControllerQueryAnalyticQueryOptions = <
  TData = Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerQueryAnalyticParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTransactionControllerQueryAnalyticQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>
  > = ({ signal }) =>
    transactionControllerQueryAnalytic(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TransactionControllerQueryAnalyticQueryResult = NonNullable<
  Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>
>;
export type TransactionControllerQueryAnalyticQueryError = ErrorType<unknown>;

export function useTransactionControllerQueryAnalytic<
  TData = Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerQueryAnalyticParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useTransactionControllerQueryAnalytic<
  TData = Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerQueryAnalyticParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useTransactionControllerQueryAnalytic<
  TData = Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerQueryAnalyticParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useTransactionControllerQueryAnalytic<
  TData = Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerQueryAnalyticParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerQueryAnalytic>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTransactionControllerQueryAnalyticQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const topHoldersControllerGetTopHolders = (
  address: string,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<CoinHolderResponse>(
    { url: `/api/top-holders/${address}`, method: "GET", signal },
    options,
  );
};

export const getTopHoldersControllerGetTopHoldersQueryKey = (
  address: string,
) => {
  return [`/api/top-holders/${address}`] as const;
};

export const getTopHoldersControllerGetTopHoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
  TError = ErrorType<unknown>,
>(
  address: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTopHoldersControllerGetTopHoldersQueryKey(address);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>
  > = ({ signal }) =>
    topHoldersControllerGetTopHolders(address, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!address,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TopHoldersControllerGetTopHoldersQueryResult = NonNullable<
  Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>
>;
export type TopHoldersControllerGetTopHoldersQueryError = ErrorType<unknown>;

export function useTopHoldersControllerGetTopHolders<
  TData = Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
  TError = ErrorType<unknown>,
>(
  address: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useTopHoldersControllerGetTopHolders<
  TData = Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
  TError = ErrorType<unknown>,
>(
  address: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useTopHoldersControllerGetTopHolders<
  TData = Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
  TError = ErrorType<unknown>,
>(
  address: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useTopHoldersControllerGetTopHolders<
  TData = Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
  TError = ErrorType<unknown>,
>(
  address: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof topHoldersControllerGetTopHolders>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTopHoldersControllerGetTopHoldersQueryOptions(
    address,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerCreateOffChainData = (
  createMemeOffChainDto: BodyType<CreateMemeOffChainDto>,
  options?: SecondParameter<typeof customClient>,
) => {
  return customClient<CreateMemeOffChainResponse>(
    {
      url: `/api/meme`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createMemeOffChainDto,
    },
    options,
  );
};

export const getMemeControllerCreateOffChainDataMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof memeControllerCreateOffChainData>>,
    TError,
    { data: BodyType<CreateMemeOffChainDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof memeControllerCreateOffChainData>>,
  TError,
  { data: BodyType<CreateMemeOffChainDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof memeControllerCreateOffChainData>>,
    { data: BodyType<CreateMemeOffChainDto> }
  > = (props) => {
    const { data } = props ?? {};

    return memeControllerCreateOffChainData(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MemeControllerCreateOffChainDataMutationResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerCreateOffChainData>>
>;
export type MemeControllerCreateOffChainDataMutationBody =
  BodyType<CreateMemeOffChainDto>;
export type MemeControllerCreateOffChainDataMutationError = ErrorType<unknown>;

export const useMemeControllerCreateOffChainData = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof memeControllerCreateOffChainData>>,
    TError,
    { data: BodyType<CreateMemeOffChainDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationResult<
  Awaited<ReturnType<typeof memeControllerCreateOffChainData>>,
  TError,
  { data: BodyType<CreateMemeOffChainDto> },
  TContext
> => {
  const mutationOptions =
    getMemeControllerCreateOffChainDataMutationOptions(options);

  return useMutation(mutationOptions);
};

export const memeControllerQueryPagination = (
  params: MemeControllerQueryPaginationParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<MemePaginationResponse>(
    { url: `/api/meme`, method: "GET", params, signal },
    options,
  );
};

export const getMemeControllerQueryPaginationQueryKey = (
  params: MemeControllerQueryPaginationParams,
) => {
  return [`/api/meme`, ...(params ? [params] : [])] as const;
};

export const getMemeControllerQueryPaginationQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerQueryPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerQueryPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMemeControllerQueryPaginationQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof memeControllerQueryPagination>>
  > = ({ signal }) =>
    memeControllerQueryPagination(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof memeControllerQueryPagination>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type MemeControllerQueryPaginationQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerQueryPagination>>
>;
export type MemeControllerQueryPaginationQueryError = ErrorType<unknown>;

export function useMemeControllerQueryPagination<
  TData = Awaited<ReturnType<typeof memeControllerQueryPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryPaginationParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerQueryPagination>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerQueryPagination>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useMemeControllerQueryPagination<
  TData = Awaited<ReturnType<typeof memeControllerQueryPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerQueryPagination>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerQueryPagination>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useMemeControllerQueryPagination<
  TData = Awaited<ReturnType<typeof memeControllerQueryPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerQueryPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useMemeControllerQueryPagination<
  TData = Awaited<ReturnType<typeof memeControllerQueryPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerQueryPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getMemeControllerQueryPaginationQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerFindKingOfTheHill = (
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<MemeResponse>(
    { url: `/api/meme/king-of-the-hill`, method: "GET", signal },
    options,
  );
};

export const getMemeControllerFindKingOfTheHillQueryKey = () => {
  return [`/api/meme/king-of-the-hill`] as const;
};

export const getMemeControllerFindKingOfTheHillQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMemeControllerFindKingOfTheHillQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>
  > = ({ signal }) => memeControllerFindKingOfTheHill(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type MemeControllerFindKingOfTheHillQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>
>;
export type MemeControllerFindKingOfTheHillQueryError = ErrorType<unknown>;

export function useMemeControllerFindKingOfTheHill<
  TData = Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
  TError = ErrorType<unknown>,
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
        TError,
        TData
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customClient>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useMemeControllerFindKingOfTheHill<
  TData = Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
        TError,
        TData
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customClient>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useMemeControllerFindKingOfTheHill<
  TData = Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customClient>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useMemeControllerFindKingOfTheHill<
  TData = Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof memeControllerFindKingOfTheHill>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customClient>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getMemeControllerFindKingOfTheHillQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerFindDetail = (
  tokenAddress: string,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<MemeResponse>(
    { url: `/api/meme/${tokenAddress}`, method: "GET", signal },
    options,
  );
};

export const getMemeControllerFindDetailQueryKey = (tokenAddress: string) => {
  return [`/api/meme/${tokenAddress}`] as const;
};

export const getMemeControllerFindDetailQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerFindDetail>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerFindDetail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMemeControllerFindDetailQueryKey(tokenAddress);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof memeControllerFindDetail>>
  > = ({ signal }) =>
    memeControllerFindDetail(tokenAddress, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!tokenAddress,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof memeControllerFindDetail>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type MemeControllerFindDetailQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerFindDetail>>
>;
export type MemeControllerFindDetailQueryError = ErrorType<unknown>;

export function useMemeControllerFindDetail<
  TData = Awaited<ReturnType<typeof memeControllerFindDetail>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerFindDetail>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerFindDetail>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useMemeControllerFindDetail<
  TData = Awaited<ReturnType<typeof memeControllerFindDetail>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerFindDetail>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerFindDetail>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useMemeControllerFindDetail<
  TData = Awaited<ReturnType<typeof memeControllerFindDetail>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerFindDetail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useMemeControllerFindDetail<
  TData = Awaited<ReturnType<typeof memeControllerFindDetail>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerFindDetail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getMemeControllerFindDetailQueryOptions(
    tokenAddress,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const allocationsControllerUpsert = (
  createManyAllocationsDto: BodyType<CreateManyAllocationsDto>,
  options?: SecondParameter<typeof customClient>,
) => {
  return customClient<boolean>(
    {
      url: `/api/allocations`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createManyAllocationsDto,
    },
    options,
  );
};

export const getAllocationsControllerUpsertMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof allocationsControllerUpsert>>,
    TError,
    { data: BodyType<CreateManyAllocationsDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof allocationsControllerUpsert>>,
  TError,
  { data: BodyType<CreateManyAllocationsDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof allocationsControllerUpsert>>,
    { data: BodyType<CreateManyAllocationsDto> }
  > = (props) => {
    const { data } = props ?? {};

    return allocationsControllerUpsert(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AllocationsControllerUpsertMutationResult = NonNullable<
  Awaited<ReturnType<typeof allocationsControllerUpsert>>
>;
export type AllocationsControllerUpsertMutationBody =
  BodyType<CreateManyAllocationsDto>;
export type AllocationsControllerUpsertMutationError = ErrorType<unknown>;

export const useAllocationsControllerUpsert = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof allocationsControllerUpsert>>,
    TError,
    { data: BodyType<CreateManyAllocationsDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationResult<
  Awaited<ReturnType<typeof allocationsControllerUpsert>>,
  TError,
  { data: BodyType<CreateManyAllocationsDto> },
  TContext
> => {
  const mutationOptions =
    getAllocationsControllerUpsertMutationOptions(options);

  return useMutation(mutationOptions);
};

export const allocationsControllerFindAllocation = (
  tokenAddress: string,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<AllocationResponse>(
    { url: `/api/allocations/${tokenAddress}`, method: "GET", signal },
    options,
  );
};

export const getAllocationsControllerFindAllocationQueryKey = (
  tokenAddress: string,
) => {
  return [`/api/allocations/${tokenAddress}`] as const;
};

export const getAllocationsControllerFindAllocationQueryOptions = <
  TData = Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAllocationsControllerFindAllocationQueryKey(tokenAddress);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof allocationsControllerFindAllocation>>
  > = ({ signal }) =>
    allocationsControllerFindAllocation(tokenAddress, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!tokenAddress,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AllocationsControllerFindAllocationQueryResult = NonNullable<
  Awaited<ReturnType<typeof allocationsControllerFindAllocation>>
>;
export type AllocationsControllerFindAllocationQueryError = ErrorType<unknown>;

export function useAllocationsControllerFindAllocation<
  TData = Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useAllocationsControllerFindAllocation<
  TData = Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useAllocationsControllerFindAllocation<
  TData = Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useAllocationsControllerFindAllocation<
  TData = Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof allocationsControllerFindAllocation>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAllocationsControllerFindAllocationQueryOptions(
    tokenAddress,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const swapRequestControllerCreate = (
  createSwapRequestDto: BodyType<CreateSwapRequestDto>,
  options?: SecondParameter<typeof customClient>,
) => {
  return customClient<void>(
    {
      url: `/api/swap-request`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createSwapRequestDto,
    },
    options,
  );
};

export const getSwapRequestControllerCreateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof swapRequestControllerCreate>>,
    TError,
    { data: BodyType<CreateSwapRequestDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof swapRequestControllerCreate>>,
  TError,
  { data: BodyType<CreateSwapRequestDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof swapRequestControllerCreate>>,
    { data: BodyType<CreateSwapRequestDto> }
  > = (props) => {
    const { data } = props ?? {};

    return swapRequestControllerCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SwapRequestControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof swapRequestControllerCreate>>
>;
export type SwapRequestControllerCreateMutationBody =
  BodyType<CreateSwapRequestDto>;
export type SwapRequestControllerCreateMutationError = ErrorType<unknown>;

export const useSwapRequestControllerCreate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof swapRequestControllerCreate>>,
    TError,
    { data: BodyType<CreateSwapRequestDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationResult<
  Awaited<ReturnType<typeof swapRequestControllerCreate>>,
  TError,
  { data: BodyType<CreateSwapRequestDto> },
  TContext
> => {
  const mutationOptions =
    getSwapRequestControllerCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

export const commentControllerCreate = (
  createCommentDto: BodyType<CreateCommentDto>,
  options?: SecondParameter<typeof customClient>,
) => {
  return customClient<CommentResponse>(
    {
      url: `/api/comment`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createCommentDto,
    },
    options,
  );
};

export const getCommentControllerCreateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof commentControllerCreate>>,
    TError,
    { data: BodyType<CreateCommentDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof commentControllerCreate>>,
  TError,
  { data: BodyType<CreateCommentDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof commentControllerCreate>>,
    { data: BodyType<CreateCommentDto> }
  > = (props) => {
    const { data } = props ?? {};

    return commentControllerCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CommentControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof commentControllerCreate>>
>;
export type CommentControllerCreateMutationBody = BodyType<CreateCommentDto>;
export type CommentControllerCreateMutationError = ErrorType<unknown>;

export const useCommentControllerCreate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof commentControllerCreate>>,
    TError,
    { data: BodyType<CreateCommentDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationResult<
  Awaited<ReturnType<typeof commentControllerCreate>>,
  TError,
  { data: BodyType<CreateCommentDto> },
  TContext
> => {
  const mutationOptions = getCommentControllerCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

export const commentControllerGetPagination = (
  params: CommentControllerGetPaginationParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal,
) => {
  return customClient<CommentPaginationResponse>(
    { url: `/api/comment`, method: "GET", params, signal },
    options,
  );
};

export const getCommentControllerGetPaginationQueryKey = (
  params: CommentControllerGetPaginationParams,
) => {
  return [`/api/comment`, ...(params ? [params] : [])] as const;
};

export const getCommentControllerGetPaginationQueryOptions = <
  TData = Awaited<ReturnType<typeof commentControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: CommentControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof commentControllerGetPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCommentControllerGetPaginationQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof commentControllerGetPagination>>
  > = ({ signal }) =>
    commentControllerGetPagination(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof commentControllerGetPagination>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CommentControllerGetPaginationQueryResult = NonNullable<
  Awaited<ReturnType<typeof commentControllerGetPagination>>
>;
export type CommentControllerGetPaginationQueryError = ErrorType<unknown>;

export function useCommentControllerGetPagination<
  TData = Awaited<ReturnType<typeof commentControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: CommentControllerGetPaginationParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof commentControllerGetPagination>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof commentControllerGetPagination>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useCommentControllerGetPagination<
  TData = Awaited<ReturnType<typeof commentControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: CommentControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof commentControllerGetPagination>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof commentControllerGetPagination>>,
          TError,
          TData
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useCommentControllerGetPagination<
  TData = Awaited<ReturnType<typeof commentControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: CommentControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof commentControllerGetPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey };

export function useCommentControllerGetPagination<
  TData = Awaited<ReturnType<typeof commentControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: CommentControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof commentControllerGetPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCommentControllerGetPaginationQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const commentControllerLikeComment = (
  likeCommentDto: BodyType<LikeCommentDto>,
  options?: SecondParameter<typeof customClient>,
) => {
  return customClient<boolean>(
    {
      url: `/api/comment/like`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: likeCommentDto,
    },
    options,
  );
};

export const getCommentControllerLikeCommentMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof commentControllerLikeComment>>,
    TError,
    { data: BodyType<LikeCommentDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof commentControllerLikeComment>>,
  TError,
  { data: BodyType<LikeCommentDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof commentControllerLikeComment>>,
    { data: BodyType<LikeCommentDto> }
  > = (props) => {
    const { data } = props ?? {};

    return commentControllerLikeComment(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CommentControllerLikeCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof commentControllerLikeComment>>
>;
export type CommentControllerLikeCommentMutationBody = BodyType<LikeCommentDto>;
export type CommentControllerLikeCommentMutationError = ErrorType<unknown>;

export const useCommentControllerLikeComment = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof commentControllerLikeComment>>,
    TError,
    { data: BodyType<LikeCommentDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationResult<
  Awaited<ReturnType<typeof commentControllerLikeComment>>,
  TError,
  { data: BodyType<LikeCommentDto> },
  TContext
> => {
  const mutationOptions =
    getCommentControllerLikeCommentMutationOptions(options);

  return useMutation(mutationOptions);
};

export const ipfsControllerUploadSingle = (
  ipfsControllerUploadSingleBody: BodyType<IpfsControllerUploadSingleBody>,
  options?: SecondParameter<typeof customClient>,
) => {
  const formData = new FormData();
  if (ipfsControllerUploadSingleBody.file !== undefined) {
    formData.append("file", ipfsControllerUploadSingleBody.file);
  }

  return customClient<void>(
    {
      url: `/api/ipfs/single`,
      method: "POST",
      headers: { "Content-Type": "multipart/form-data" },
      data: formData,
    },
    options,
  );
};

export const getIpfsControllerUploadSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ipfsControllerUploadSingle>>,
    TError,
    { data: BodyType<IpfsControllerUploadSingleBody> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof ipfsControllerUploadSingle>>,
  TError,
  { data: BodyType<IpfsControllerUploadSingleBody> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ipfsControllerUploadSingle>>,
    { data: BodyType<IpfsControllerUploadSingleBody> }
  > = (props) => {
    const { data } = props ?? {};

    return ipfsControllerUploadSingle(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type IpfsControllerUploadSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof ipfsControllerUploadSingle>>
>;
export type IpfsControllerUploadSingleMutationBody =
  BodyType<IpfsControllerUploadSingleBody>;
export type IpfsControllerUploadSingleMutationError = ErrorType<unknown>;

export const useIpfsControllerUploadSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ipfsControllerUploadSingle>>,
    TError,
    { data: BodyType<IpfsControllerUploadSingleBody> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationResult<
  Awaited<ReturnType<typeof ipfsControllerUploadSingle>>,
  TError,
  { data: BodyType<IpfsControllerUploadSingleBody> },
  TContext
> => {
  const mutationOptions = getIpfsControllerUploadSingleMutationOptions(options);

  return useMutation(mutationOptions);
};
